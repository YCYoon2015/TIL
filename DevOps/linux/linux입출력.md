# Linux 입출력

> 리눅스를 전반적으로 정리합니다.

## 출력

### echo

`echo` 명령어는 주어진 인자나 텍스트를 화면에 출력하는 데 사용됩니다. 다음은 `echo` 명령어에서 자주 사용되는 옵션들에 대한 설명입니다:

- `-n`: 출력 후에 줄 바꿈을 하지 않고 출력합니다. 이 옵션을 사용하면 텍스트가 출력된 후 커서가 같은 줄에 위치하게 됩니다.
- `-e`: 이스케이프(escape) 시퀀스를 해석하도록 설정합니다. 이 옵션을 사용하면 `\n`, `\t`, 등과 같은 이스케이프 시퀀스를 적절히 해석하여 출력할 수 있습니다.
- `-E`: 이스케이프 시퀀스를 해석하지 않도록 설정합니다. 이 옵션이 설정되면 이스케이프 시퀀스가 그대로 출력됩니다.
- `-c`: 셸 스크립트 내에서 `echo` 명령어가 호출될 때 명령어 대신 해당 스크립트의 내용을 표시합니다. 주로 디버깅 목적으로 사용됩니다.
- `-h` 또는 `--help`: 도움말 메시지와 함께 `echo` 명령어의 사용법을 출력합니다.

옵션은 `echo` 명령어를 보다 유연하게 사용할 수 있도록 도와줍니다. `-n` 옵션을 사용하면 줄 바꿈 없이 여러 줄의 텍스트를 출력하거나, `-e` 옵션을 사용하여 이스케이프 시퀀스를 해석하여 특수한 문자를 출력할 수 있습니다. `-c` 옵션은 특정 스크립트의 내용을 표시하고 디버깅에 활용할 수 있습니다.



### 와일드카드

`echo` 명령어와 와일드카드(`*`, `?`, `[ ]` 등)를 함께 사용하여 특정 패턴에 해당하는 파일이나 디렉토리 목록을 출력할 수 있습니다. 와일드카드는 패턴 매칭에 사용되며, 해당 패턴에 일치하는 파일이나 디렉토리를 대체하여 출력합니다.

다음은 `echo` 명령어와 와일드카드를 함께 사용하는 몇 가지 예시입니다:

1. 모든 파일 출력:

   ```
   echo *
   ```

   현재 디렉토리에 있는 모든 파일의 이름을 출력합니다.

2. 특정 확장자를 가진 파일 출력:

   ```
   echo *.txt
   ```

   현재 디렉토리에서 확장자가 `.txt`인 모든 파일의 이름을 출력합니다.

3. 특정 패턴을 가진 파일 출력:

   ```
   echo file*
   ```

   현재 디렉토리에서 이름이 "file"로 시작하는 모든 파일의 이름을 출력합니다.

4. 디렉토리 출력:

   ```
   echo */
   ```

   현재 디렉토리에 있는 모든 디렉토리의 이름을 출력합니다.

5. 특정 문자열이 포함된 파일 출력:

   ```
   echo *pattern*
   ```

   현재 디렉토리에서 "pattern"이라는 문자열을 포함하는 모든 파일의 이름을 출력합니다.

6. 특정 문자 범위 일치:

   ```
   echo file[0-9].txt
   ```

   현재 디렉토리에서 "file" 다음에 0부터 9까지의 숫자가 오고 ".txt"로 끝나는 파일의 이름을 출력합니다. 예를 들어, "file1.txt", "file2.txt" 등과 일치합니다.

7. 문자 집합 일치:

   ```
   echo file[abc].txt
   ```

   현재 디렉토리에서 "file" 다음에 "a", "b", "c" 중 하나가 오고 ".txt"로 끝나는 파일의 이름을 출력합니다. 예를 들어, "filea.txt", "fileb.txt" 등과 일치합니다.

8. 부정적인 일치:

   ```
   echo file[!0-9].txt
   ```

   현재 디렉토리에서 "file" 다음에 숫자가 아닌 어떤 문자가 오고 ".txt"로 끝나는 파일의 이름을 출력합니다. 숫자가 아닌 문자로 시작하는 파일과 일치합니다.

9. 여러 문자 범위 및 집합 일치:

   ```
   echo file[0-9a-fA-F].txt
   ```

   현재 디렉토리에서 "file" 다음에 0부터 9까지의 숫자 또는 a부터 f까지의 소문자 또는 대문자 알파벳 중 하나가 오고 ".txt"로 끝나는 파일의 이름을 출력합니다.



### POSIX

POSIX 표기법은 파일 경로나 패턴 매칭에서 사용되는 표준화된 표기법입니다. POSIX는 "Portable Operating System Interface"의 약자로, 다양한 유닉스 및 유닉스 계통 운영 체제에서 호환성과 이식성을 보장하기 위해 개발되었습니다.

POSIX 표기법에서 사용되는 주요 요소는 다음과 같습니다:

1. **슬래시 (/)**: 디렉토리 구분자로 사용됩니다. POSIX 표기법에서 디렉토리 경로는 슬래시로 구분됩니다. 예를 들어, `/home/user/Documents`는 "user" 사용자의 "Documents" 디렉토리를 나타냅니다.
2. **점 (.)**: 현재 디렉토리를 나타내는 특수한 기호입니다. `.`은 현재 디렉토리를, `..`은 상위 디렉토리를 의미합니다. 예를 들어, `/home/user/./Documents`는 `/home/user/Documents`와 동일한 경로를 나타냅니다.
3. **와일드카드**: POSIX 표기법에서 와일드카드로는 `*`와 `?`가 주로 사용됩니다. `*`는 임의의 길이의 문자열을 나타내는 와일드카드로, `?`는 한 글자를 나타내는 와일드카드입니다.
4. **대괄호 ([])**: 대괄호는 문자 집합을 표현하는 데 사용됩니다. 예를 들어, `[abc]`는 "a", "b", "c" 중 하나의 문자와 일치합니다.
5. **대괄호의 범위 표현**: POSIX 표기법에서 대괄호 내에서 대괄호와 하이픈(-)을 사용하여 문자의 범위를 표현할 수 있습니다. 예를 들어, `[a-z]`는 소문자 알파벳 중 하나의 문자와 일치합니다.

POSIX 표기법은 다양한 유닉스 및 유닉스 계통 운영 체제에서 일관성 있고 이식성 있는 파일 경로 및 패턴 매칭을 지원합니다. 따라서 POSIX 표기법을 사용하면 특정 운영 체제에 종속되지 않고 다양한 플랫폼에서 호환성을 유지할 수 있습니다.



| POSIX      | 비표준   | 펄/Tcl | Vim                       | ASCII                               | 설명                     |
| ---------- | -------- | ------ | ------------------------- | ----------------------------------- | ------------------------ |
| [:alnum:]  |          |        |                           | [A-Za-z0-9]                         | 영숫자                   |
|            | [:word:] | \w     | \w                        | [A-Za-z0-9_]                        | 영숫자 + "_"             |
|            |          | \W     | \W                        | [^A-Za-z0-9_]                       | 낱말이 아닌 문자         |
| [:alpha:]  |          |        | \a                        | [A-Za-z]                            | 알파벳 문자              |
| [:blank:]  |          |        | \s                        | [ \t]                               | 공백과 탭                |
|            |          | \b     | \< \>                     | (?<=\W)(?=\w)\|(?<=\w)(?=\W)        | 낱말 경계                |
| [:cntrl:]  |          |        |                           | [\x00-\x1F\x7F]                     | 제어 문자                |
| [:digit:]  |          | \d     | \d                        | [0-9]                               | 숫자                     |
|            |          | \D     | \D                        | [^0-9]                              | 숫자가 아닌 문자         |
| [:graph:]  |          |        |                           | [\x21-\x7E]                         | 보이는 문자              |
| [:lower:]  |          |        | \l                        | [a-z]                               | 소문자                   |
| [:print:]  |          |        | \p                        | [\x20-\x7E]                         | 보이는 문자 및 공백 문자 |
| [:punct:]  |          |        |                           | [][!"#$%&'()*+,./:;<=>?@\^_`{\|}~-] | 구두점                   |
| [:space:]  |          | \s     | \_s (단순히 줄 끝에 추가) | [ \t\r\n\v\f]                       | 공백 문자                |
|            |          | \S     |                           | [^ \t\r\n\v\f]                      | 공백이 아닌 모든 문자    |
| [:upper:]  |          |        | \u                        | [A-Z]                               | 대문자                   |
| [:xdigit:] |          |        | \x                        | [A-Fa-f0-9]                         | 16진수                   |



## 일부 조회

`tail` 명령어 옵션:

- `-n <숫자>`: 지정한 숫자만큼의 끝 부분을 출력합니다. 예를 들어 `tail -n 10 filename.txt`는 파일 `filename.txt`의 마지막 10줄을 출력합니다.
- `-f`: 파일을 실시간으로 감시하면서, 파일에 새로운 내용이 추가될 때마다 출력합니다. 파일의 끝을 읽은 후에도 계속해서 출력을 갱신하므로, 로그 파일 등을 실시간으로 모니터링할 때 유용합니다.

`head` 명령어 옵션:

- `-n <숫자>`: 지정한 숫자만큼의 앞 부분을 출력합니다. 예를 들어 `head -n 5 filename.txt`는 파일 `filename.txt`의 처음 5줄을 출력합니다.
- `-f`: 파일의 처음 부분을 출력한 후에도 파일을 계속해서 모니터링하며, 새로운 내용이 추가될 때마다 출력을 갱신합니다.

이렇게 옵션을 사용하여 `tail`과 `head` 명령어를 활용하면 파일의 특정 부분만 출력하거나 파일의 변화를 실시간으로 모니터링할 수 있습니다.



## 파일 정보 조회

### file

리눅스의 `file` 명령어는 주어진 파일의 유형과 속성을 확인하는 데 사용됩니다. 해당 파일이 어떤 종류인지, 텍스트 파일인지 이진 파일인지, 압축 파일인지 등을 식별할 수 있습니다. 아래에 `file` 명령어에서 자주 사용되는 옵션들을 설명해드리겠습니다:

- `-b` 또는 `--brief`: 간결한 형식으로 출력합니다. 파일 이름만 출력하고 유형을 자세히 표시하지 않습니다.
- `-i` 또는 `--mime`: MIME 유형을 출력합니다. 파일의 유형을 MIME 유형으로 표시합니다.
- `-z` 또는 `--uncompress`: 압축 파일인 경우, 압축을 풀어서 파일 유형을 확인합니다.
- `-L` 또는 `--dereference`: 심볼릭 링크를 따라가서 링크된 파일의 유형을 확인합니다.
- `-f <파일>` 또는 `--files-from=<파일>`: 파일 이름이 주어진 파일에서 읽혀지고, 각 파일의 유형을 확인합니다.
- `-r` 또는 `--recursive`: 디렉토리를 재귀적으로 탐색하여 파일 유형을 확인합니다.
- `-v` 또는 `--version`: `file` 명령어의 버전 정보를 출력합니다.
- `-h` 또는 `--help`: 도움말 메시지와 함께 사용법을 출력합니다.

### ls -l

`ls -l` 명령은 현재 디렉토리의 파일과 디렉토리의 자세한 정보를 리스트 형태로 출력합니다. 결과에는 각 파일 또는 디렉토리에 대한 다양한 속성과 권한 정보가 포함됩니다. 아래는 `ls -l` 결과에서 표시되는 정보에 대한 설명입니다:

1. **파일/디렉토리 권한 (File/Directory Permissions)**: 출력의 첫 번째 열에 위치하며, 해당 파일 또는 디렉토리의 접근 권한을 나타냅니다. 일반적으로 10개의 문자로 표시되며, 세 그룹(소유자, 그룹, 기타 사용자)으로 나누어져 있습니다. 각 그룹은 읽기(`r`), 쓰기(`w`), 실행(`x`) 권한을 나타내는 문자로 표시됩니다.
2. **링크 수 (Link Count)**: 출력의 두 번째 열에 위치하며, 해당 파일 또는 디렉토리에 대한 하드 링크의 수를 나타냅니다. 링크 수는 해당 파일 또는 디렉토리를 가리키는 하드 링크의 개수를 나타냅니다.
3. **소유자 (Owner)**: 출력의 세 번째 열에 위치하며, 해당 파일 또는 디렉토리의 소유자를 나타냅니다. 일반적으로 사용자 이름이 표시됩니다.
4. **그룹 (Group)**: 출력의 네 번째 열에 위치하며, 해당 파일 또는 디렉토리가 속한 그룹을 나타냅니다. 일반적으로 그룹 이름이 표시됩니다.
5. **파일 크기 (File Size)**: 출력의 다섯 번째 열에 위치하며, 해당 파일의 크기를 바이트 단위로 나타냅니다.
6. **수정 일자와 시간 (Modification Date and Time)**: 출력의 여섯 번째 열에 위치하며, 해당 파일 또는 디렉토리가 마지막으로 수정된 날짜와 시간을 나타냅니다.
7. **파일/디렉토리 이름 (File/Directory Name)**: 출력의 일곱 번째 열에 위치하며, 해당 파일 또는 디렉토리의 이름을 나타냅니다.



## 표준입출력

리눅스 표준 입출력은 리눅스 운영 체제에서 프로세스와 상호 작용하기 위해 사용되는 표준화된 입출력 메커니즘입니다. 이 메커니즘은 사용자가 키보드로 입력하고 화면에 출력하는 등의 작업을 가능하게 합니다.

리눅스에서는 모든 장치와 파일을 일종의 파일로 취급합니다. 이는 입력과 출력을 위해 표준 입출력 스트림을 사용하는데, 주로 세 가지 스트림을 사용합니다.

1. 표준 입력(stdin): 키보드나 다른 입력 장치로부터의 입력을 읽기 위한 스트림입니다. 보통 표준 입력은 사용자가 프로그램에 입력한 데이터를 받기 위해 사용됩니다. 이 스트림은 파일 디스크립터 번호 0으로 표시됩니다.
2. 표준 출력(stdout): 프로그램이 결과를 출력하는데 사용하는 스트림입니다. 일반적으로 표준 출력은 모니터 또는 터미널 화면에 텍스트를 출력하는 용도로 사용됩니다. 이 스트림은 파일 디스크립터 번호 1로 표시됩니다.
3. 표준 오류(stderr): 프로그램이 오류 메시지나 디버깅 정보를 출력하는데 사용하는 스트림입니다. 표준 출력과는 별도로 오류 메시지를 구분하여 출력하기 위해 사용됩니다. 이 스트림은 파일 디스크립터 번호 2로 표시됩니다.

이러한 표준 입출력 스트림은 리다이렉션과 함께 사용될 수 있습니다. 리다이렉션은 표준 입력이나 표준 출력을 파일로 리디렉션하거나, 한 프로세스의 출력을 다른 프로세스의 입력으로 보내는 등의 작업을 의미합니다. 이를 통해 파일에 결과를 저장하거나 다른 프로그램과의 통신을 가능하게 합니다.

리눅스에서는 표준 입출력을 다루기 위해 C 언어에서 제공하는 함수들을 사용할 수 있습니다. 가장 일반적인 함수로는 `scanf`, `printf`, `fgets`, `fputs` 등이 있습니다. 이러한 함수들은 표준 입출력 스트림을 사용하여 데이터를 읽고 쓰는 작업을 수행합니다.

리눅스 표준 입출력은 사용자와 프로그램 간의 상호 작용과 데이터 흐름을 효율적으로 관리하기 위한 중요한 메커니즘입니다.

![표준 스트림 - 위키백과, 우리 모두의 백과사전](https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Stdstreams-notitle.svg/1200px-Stdstreams-notitle.svg.png)

### 연산자 > & >>

#### 출력

`>` 연산자는 출력을 파일에 리다이렉트하는 데 사용됩니다. `>` 연산자는 파일이 이미 존재할 경우 해당 파일을 덮어쓰고, 존재하지 않을 경우 새로운 파일을 생성합니다.

`>>` 연산자는 출력을 파일에 추가하는 데 사용됩니다. `>>` 연산자를 사용하면 출력이 파일에 추가되며, 기존 파일의 내용은 유지됩니다.

1. 표준 출력을 파일에 리다이렉션하는 예제:

```
echo "Hello, world!" > output.txt
```

위 예제는 "Hello, world!"라는 문자열을 출력하고, `>` 연산자를 사용하여 해당 출력을 "output.txt" 파일로 리다이렉션합니다. "output.txt" 파일이 이미 존재할 경우 내용이 덮어쓰이고, 존재하지 않을 경우 새로운 파일이 생성됩니다.

1. 표준 출력을 파일에 추가하는 예제:

```
echo "New content" >> output.txt
```

위 예제는 "New content"라는 문자열을 출력하고, `>>` 연산자를 사용하여 해당 출력을 "output.txt" 파일에 추가합니다. 기존 파일의 내용은 유지되며, "New content"가 파일에 추가됩니다.

위의 예시에서는 `echo` 명령어를 사용하여 간단한 출력을 생성했지만, 실제로는 다른 프로그램의 출력을 파일에 리다이렉션하는 데에도 사용할 수 있습니다. `>` 및 `>>` 연산자는 일반적으로 스크립트 파일에서 출력을 파일에 저장하거나 로그 파일을 유지하는 데에 유용하게 사용됩니다.

#### 입력

1. `<` 식별자를 사용하여 파일 입력 받기:

```
bashCopy code#!/bin/bash

# 파일로부터 입력 받기
while IFS= read -r line
do
    echo "입력된 내용: $line"
done < input.txt
```

위 예제는 `input.txt` 파일로부터 입력을 받아 한 줄씩 처리하는 스크립트입니다. `while` 루프를 사용하여 파일에서 한 줄씩 읽어들이고, 각 줄을 `$line` 변수에 저장한 후 처리합니다. `<` 식별자를 사용하여 `input.txt` 파일을 표준 입력으로 리다이렉션하여 파일로부터 입력을 받습니다.

2. `<<` 식별자를 사용하여 여러 줄 입력 받기:

```
bashCopy code#!/bin/bash

# 여러 줄 입력 받기
cat << EOF
이것은
여러 줄의
입력입니다.
EOF
```

위 예제는 `<<` 식별자를 사용하여 여러 줄의 입력을 받는 스크립트입니다. `cat` 명령어를 사용하여 `<< EOF`와 `EOF` 사이의 여러 줄을 입력으로 받습니다. `EOF`는 종료 식별자로 사용되며, 입력의 끝을 나타냅니다.

이렇게 식별자 `<`와 `<<`를 사용하면 파일에서 입력을 받거나 여러 줄의 입력을 처리할 수 있습니다.



## Pipe

파이프는 한 프로세스의 출력을 다른 프로세스의 입력으로 연결하는 데 사용됩니다.

```
ls -l | grep ".txt"
```

위 예시에서 `ls -l` 명령은 현재 디렉토리의 파일 목록을 자세히 출력하고, `grep ".txt"` 명령은 그 출력에서 ".txt"로 끝나는 파일만 필터링합니다. 파이프(|)를 사용하여 `ls -l`의 출력을 `grep ".txt"`의 입력으로 전달하여 필터링 작업을 수행합니다.

파이프를 사용하여 데이터를 전달할 때, 왼쪽에 있는 프로세스의 출력은 오른쪽에 있는 프로세스의 입력으로 연결됩니다. 이를 통해 다양한 명령어나 프로그램을 조합하여 데이터를 가공하거나 원하는 결과를 얻을 수 있습니다.

또 다른 예시로, 다음은 `ps aux` 명령어의 출력을 `grep "python"` 명령어의 입력으로 전달하여 현재 실행 중인 모든 Python 프로세스를 필터링하는 예시입니다:

```
ps aux | grep "python"
```

위 예시에서 `ps aux`는 현재 실행 중인 모든 프로세스를 보여주고, `grep "python"`은 그 출력에서 "python"이라는 단어를 필터링하여 Python 프로세스만 보여줍니다.

이와 같이 파이프를 사용하면 여러 프로세스를 연결하여 데이터를 처리하고 원하는 결과를 얻을 수 있습니다. 파이프는 리눅스에서 자주 사용되는 강력한 기능 중 하나입니다.



### tee

`tee` 명령어는 리눅스에서 사용되는 유용한 명령어로, 입력을 받아 파일과 표준 출력 모두에 복사하는 기능을 제공합니다. 이를 통해 입력을 동시에 파일에 저장하고 터미널에 출력할 수 있습니다.

`tee` 명령어의 일반적인 구문은 다음과 같습니다:

```
command | tee [옵션] [파일1] [파일2] ...
```

여기서 `command`는 입력을 생성하는 프로세스나 명령어를 의미합니다. 파이프(`|`)를 통해 `command`의 출력을 `tee` 명령어에 전달하며, `tee` 명령어는 출력을 받아 지정한 파일들과 표준 출력으로 복사합니다.

주요 옵션은 다음과 같습니다:

- `-a` 옵션: 출력을 파일에 추가합니다. 기본적으로 `tee`는 파일을 덮어씁니다.
- `-i` 옵션: 인터액티브 모드로 동작하며, 파일이 이미 존재할 경우 덮어쓸지 여부를 묻습니다.

다음은 몇 가지 `tee` 명령어의 예시입니다:

1. 표준 출력을 파일에 저장하면서 터미널에 출력하기:

```
ls -l | tee output.txt
```

위 예제는 `ls -l` 명령어의 출력을 `output.txt` 파일에 저장하면서 동시에 터미널에 출력합니다. `tee` 명령어를 사용하여 출력을 `output.txt` 파일로 복사합니다.

2. 표준 출력을 여러 파일에 저장하면서 터미널에 출력하기:

```
ls -l | tee output1.txt output2.txt
```

위 예제는 `ls -l` 명령어의 출력을 `output1.txt`와 `output2.txt` 두 개의 파일에 저장하면서 동시에 터미널에 출력합니다.



### mkfifo

`mkfifo`는 리눅스에서 사용되는 명령어로, 이름 있는 파이프(named pipe)를 생성하는 데 사용됩니다. 이름 있는 파이프는 파일 시스템에 특정 경로에 생성되어 다른 프로세스 간의 양방향 통신에 사용될 수 있습니다.

`mkfifo` 명령어의 일반적인 구문은 다음과 같습니다:

```
mkfifo [옵션] [이름]
```

여기서 `[옵션]`은 선택적인 옵션을 지정할 수 있으며, `[이름]`은 생성할 파이프의 이름을 나타냅니다.

- `-m <모드>` 또는 `--mode=<모드>`: 생성된 파이프의 퍼미션 모드를 설정합니다. 모드는 앞서 사용되는 숫자 모드 표기법 (예: 644, 755 등)으로 지정됩니다.
- `-Z` 또는 `--context`: SELinux 보안 컨텍스트를 파이프에 적용합니다.
- `-v` 또는 `--verbose`: 작업을 상세하게 출력하여 진행 상황을 표시합니다.
- `-h` 또는 `--help`: 도움말을 표시하고 `mkfifo` 명령어의 사용법을 보여줍니다.

다음은 `mkfifo` 명령어를 사용한 예시입니다:

1. 이름 있는 파이프 생성:

```
mkfifo mypipe
```

위 예제는 `mypipe`라는 이름으로 파이프를 생성합니다. 이 파이프는 파일 시스템에 `mypipe`라는 파일로 생성되며, 이제 다른 프로세스에서 해당 파일을 통해 통신할 수 있습니다.

1. 파이프를 사용한 프로세스 간 통신: 다음은 `mkfifo`를 사용하여 파이프를 생성하고, 두 개의 독립적인 프로세스 간에 파이프를 통해 데이터를 전달하는 예시입니다.

프로세스 1 (데이터 쓰기):

```
echo "Hello, World!" > mypipe
```

위 예제는 "Hello, World!"라는 데이터를 `mypipe` 파이프로 씁니다.

프로세스 2 (데이터 읽기):

```
cat < mypipe
```

위 예제는 `mypipe` 파이프로부터 데이터를 읽어와 터미널에 출력합니다. 이 경우, "Hello, World!"라는 데이터가 출력됩니다.

이를 통해 `mkfifo`를 사용하여 이름 있는 파이프를 생성하고, 다른 프로세스들 간에 데이터를 전달하고 통신할 수 있습니다. 파이프는 프로세스 간 통신이 필요한 상황에서 유용하게 사용됩니다.
