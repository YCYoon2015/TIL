# Index

### 인덱스란?

추가적인 ‘메모리 공간’과 ‘효율적인 index 작성’이라는 노력을 통해서 데이터를 더 빨리 찾을수 있게하는 자료구조이다. index를 통해 select외에 update, delete 성능도 같이 상승하는데 이는 해당 연산을 수행하려면 해당 대상을 조회해야 하기 때문이다.

인덱스 재 작성이 자주 이러나는 환경이라면 인덱스를 없에고 전체 조회를 선택하는방법을 택할 수 있다. 특히 Insert의 경우 중간에 삽입될 경우 많은 인덱스 변경을 유발하여 효율이 떨어질 수 있다.

### 엔덱스 관리

효율적인 index 작성을 위해 상황별로 다음 연산이 수행된다.

- Insert: 새로운 데이터에 대한 인덱스를 추가함
- Delete: 삭제하는 데이터의 인덱스를 사용하지 않겠다는 표시를 함
- Update: 기존 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스를 추가함

### 인덱스 vs PK

- 일반적으로 RDMBS에서 PK는 자동으로 index가 된다.
- 하지만 PK이외에 직접 index 지정이 가능하다.
- 조회시 index는 따로 관리되기에 전체를 조회하는것이 아닌 index 찾는 알고리즘으로 해당 행을 조회한다.

### 인덱스 자료구조

인덱스를 구현하기 위해서는 다양한 자료구조와 알고리즘이 사용된다.

- 해시 테이블
  - 해시 테이블은 key, value 형태로 저장된 데이터를 꺼내온다.
  - 해시 테이블은 등호(=) 연산에는 빠르나, 부등호 연산(>)은 모든 값을 조회해야 한다는 단점이 있다.
- B+ Tree
  - B+ Tree는 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.
  - 전체적인 구조는 하나의 노드는 2쌍의 (시작점, pointer)를 가진다.
  - 시작점의 해당한는 pointer에는 다시 노드가 있을수도 있고, Leaf노드가 있을수도 있다.
  - Leaf노드의 경우 각 index값에 해당하는 data가 있습니다.
  - Insert 과정은 해당 index 범위를 찾아가서 leaf 노드에 값을 넣는것입니다.
    - 이때 leaf노드 최대 key개수가 초과하면 하나씩 부모에게 올려서 최종적으로 노드 크기를 맞춥니다.
  - Delete 과정은 해당 Leaf에 데이터를 삭제하고 맞춰나가는 방식입니다. 삭제가 수행되지 않고, 데이터만 지워질 수도 있습니다.

### Primary Index vs Secondary Index

Primary index는 여지까지 살펴본 하나의 key 값이다. 중복을 피하고,  해당 자료의 위치를 가리키는 역할을 한다.

Secondary Index는 보조 인덱스로 포인터 기능만 수행되고, 포인터 자체를 변경시킬 권한은 없다.

### Composite Index

결합 인덱스라고도 부르며 인덱스 생성시 두개 이상의 컬럼을 합쳐서 인덱스를 만드는 방법이다.

주로 Where절의 조건 컬럼이 2개이상 and로 연결되는 경우 사용된다.

### Index 의 성능과 고려해야할 사항

어떤 컬럼을 인덱스로 잡을것인지가 가장 중요하다. 가장 조회로 많이 사용되며, 아래 4가지 조건에 맞는 컬럼이 좋은 인덱스이다.

- 카디널리티
  - 얼마나 중복되는지 나타내는 값이다. 따라서 낮을수록 index성능을 높인다.
- 선택도
  - 전체 데이터 중에 특정값을 얼마나 잘 선택할 수 있는지 지표이다. 낮을수록 좋다.
- 활용도
  - 값이 Where절에서 얼마나 자주 사용되지는지 나타내는 지표이다. 관심사로 볼수있다.
- 중복도
  - 중복이 없을수록 좋은 index이다.
