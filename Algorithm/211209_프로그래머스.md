# 211209 프로그래머스

## 조이스틱 (level 2)

> https://programmers.co.kr/learn/courses/30/lessons/42860

### 문제 설명

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

```
▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동
```

예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.

```
- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
```

만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

### 알고리즘 포인트

문자열, 그리디

### 나의 답안

```python
def solution(name):
    # 알파벳을 만드는 수 누적
    cnt = 0
    for i in range(len(name)):
        cnt += min(ord(name[i]) - ord('A'), ord('Z') - ord(name[i]) + 1)
    
    # 알파벳 자리까지 이동하는 최소 수 
    # 1. 그냥 한쪽으로 쭉 간다.
    case1 = len(name)-1
    # 2. 오른쪽으로 갔다가 왼쪽으로 간다. (A가 연속일 경우)
    lenth = 0 # 연속한 A 최대 개수 
    while True:
        lenth += 1
        if not 'A'*lenth in name:
            lenth -= 1
            break
    if lenth >= 1:
        l = name.find('A'*lenth)
        r = l + lenth - 1
        case2 = l-1 + l-1 + (len(name)-r-1)
        print(case1, case2)
        return min(case1, case2) + cnt
    else: # A가 하나도 없는경우
        return case1 + cnt
```

### 생각

처음에 완전탐색으로 문제를 풀었다가 시간초과가 발생하였다. 생각해보니 case가 2가지 경우밖에 없어서 둘다 구해서 최소값을 찾으면 해결되는 문제이다. 문자열을 다루는 방법이 핵심인데, 나는 최대 A를 find를 이용해서 찾아서 문제를 해결하였다.

다른 풀이를 보니 논리는 거의 비슷하지만, 문자열을 찾는 방식이 달랐다. r, l을 찾는 목표는 같으나 while를 써서 찾은 사람들이 많아 보였다. 내 풀이와 성능적인 차이는 없어보인다. 가독성에서는 내 코드가 더 맘에 드는데 이건 아직 뭐가 좋은 코드인지 모르겠다.
