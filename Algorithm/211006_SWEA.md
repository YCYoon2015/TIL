# 211006 SWEA

## 화물 도크 

> 주소 없음. SWEA 5202 문제

### 문제 설명

24시간 운영되는 물류센터에는 화물을 싣고 내리는 도크가 설치되어 있다.

0시부터 다음날 0시 이전까지 A도크의 사용신청을 확인해 최대한 많은 화물차가 화물을 싣고 내릴 수 있도록 하면, 최대 몇 대의 화물차가 이용할 수 있는지 알아내 출력하는 프로그램을 만드시오.

신청서에는 작업 시작 시간과 완료 시간이 매시 정각을 기준으로 표시되어 있고, 앞 작업의 종료와 동시에 다음 작업을 시작할 수 있다.

예를 들어 앞 작업의 종료 시간이 5시면 다음 작업의 시작 시간은 5시부터 가능하다.

### 알고리즘 포인트

그리디 알고리즘이다. dfs로 완전탐색하여 최적을 구 할 수 있으나, 시간 효율이 떨어진다.

### 나의 답안

```python
T = int(input())
for tc in range(1, T+1):
    # 1. 입력
    n = int(input())
 
    times = []
    for _ in range(n):
        s, e = map(int, input().split())
        times.append((s, e))
 
    # 2. 끝 시간순 정렬
    times.sort(key=lambda a: a[1])
 
    # 3. 주워담기
    ans = 0
    end_time = 0
    for time in times:
        if end_time <= time[0]: # 다음일 시작시간이 이후면
            ans += 1 # 작업
            end_time = time[1] # 작업 끝나는 시간
 
    print(f'#{tc} {ans}')
```

### 생각

문제 유형을 알고있어 그리디 알고리즘으로 쉽게 해결하였다. 하지만 이 문제를 처음 만났을때는 그렇게 풀기 힘들것 같다.



---



## 베이비진 게임

> 주소없음. SWEA 5203 문제

### 문제 설명

0부터 9까지인 숫자 카드 4세트를 섞은 후 6개의 카드를 골랐을 때, 연속인 숫자가 3개 이상이면 run, 같은 숫자가 3개 이상이면 triplet이라고 한다.

게임을 시작하면 플레이어1과 플레이어 2가 교대로 한 장 씩 카드를 가져가며, 6장을 채우기 전이라도 먼저 run이나 triplet이 되는 사람이 승자가 된다.

두 사람이 가져가게 되는 순서대로 12장의 카드에 대한 정보가 주어졌을 때 승자를 알아내는 프로그램을 작성하시오. 만약 무승부인 경우 0을 출력한다.

예를 들어 9 9 5 6 5 6 1 1 4 2 2 1인 경우, 플레이어 1은 9, 5, 5, 1, 4, 2카드를, 플레이어2는 9, 6, 6, 1, 2, 1을 가져가게 된다.

이때는 카드를 모두 가져갈 때 까지 run이나 triplet이 없으므로 무승부가 된다.

### 알고리즘 포인트

기초적인 구현. 리스트 활용 

### 나의 답안

```python
T = int(input())
for tc in range(1, T+1):
    # 1. 입력
    games = list(map(int, input().split()))
 
    # 2. 한장씩 가져가며 승부
    win = 0
    player_1 = [0] * 10
    player_2 = [0] * 10
    for idx in range(len(games)):
        if win != 0: # 승부가 이미 발생했으면
            break
        num = games[idx]
        if idx % 2 == 0: # 플레이어 1
            player_1[num] += 1 # 카드 더하기
            # 3. 베이비진 확인
            for i in range(8):
                if (player_1[i] == 3) or (player_1[i] >= 1 and player_1[i+1] >= 1 and player_1[i+2] >= 1):
                    win = 1
                    break
            for j in range(8, 10):
                if player_1[j] == 3:
                    win = 1
                    break
        else: # 플레이어 2
            player_2[num] += 1  # 카드 더하기
            # 3. 베이비진 확인
            for i in range(8):
                if (player_2[i] == 3) or (player_2[i] >= 1 and player_2[i + 1] >= 1 and player_2[i + 2] >= 1):
                    win = 2
                    break
            for j in range(8, 10):
                if player_2[j] == 3:
                    win = 2
                    break
 
    print(f'#{tc} {win}')
```

### 생각

SWEA에서 좋아하는 베이비진 문제이다. 베이비진 확인을 어떻게 할지 고민하면, 구조를 어떻게 짤지 생각할 수 있다. 베이비진 확인은 리스트로된 덱에서 확인이 편하기 때문에 입력 구조를 리스트를 통해 받았다. 

코드에서 중복된 부분이 있다. 이를 함수로 나타내는것이 더 깔끔하나, 코딩 테스트의 목적상 크게 지저분하지 않으며 시간을 줄일 수 있기에 반복적인 코드를 작성하였다.