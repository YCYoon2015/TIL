### 가장 기본 - 단일서버

단순하게 한개 서버가 처리하는 구조. 

장점

- 단순하고 유지보수가 쉽다.
- 네트워크 구성도 간단해서 관리가 쉽다
- 개발 배포가 간단하고 테스트도 비교적 쉽다
- 개발시에 고려할게 좀 적다 

단점

- 확장성이 부족해서 트래픽이 는다면 결국은 한계가 온다.
- 단일 장애점이 된다. 장애시 전체 시스템이 다운된다.
- 자원 활용에 비효율성이 있다. 특정 시점에 과부하가 오면 전체 성능 저하로 이뤄진다.



### 수평 확장 vs 수직 확장

수직 확장

- 기존 서버 HW 성능을 향상하는 방법. 단순하게 좋은 부품 쓰는것.

수평확장

- 서버 여러대를 추가하여 트래픽을 분산시켜서 처리하는 방법

| **특징**            | **수직 확장 (Vertical Scaling)**          | **수평 확장 (Horizontal Scaling)**          |
|----------------------|-------------------------------------------|---------------------------------------------|
| **장점**             | - 설정과 관리가 쉬움<br>- 기존 앱 수정 필요 없음<br>- 한 서버에서 많은 요청 처리 가능<br>- 데이터 일관성 유지 쉬움 | - 서버 추가로 무한 확장 가능<br>- 대규모 트래픽 처리 가능<br>- 서버 다운돼도 다른 서버가 처리<br>- 트래픽 분산으로 병목 줄임<br>- 자원 효율적 활용 가능 |
| **단점**             | - 하드웨어 업그레이드 한계 있음<br>- 일정 수준 이상 성능 향상 어려움<br>- 고성능 하드웨어 비용 높음<br>- 특정 시점 이후 비용 대비 성능 떨어짐<br>- 서버 다운되면 전체 중단 | - 네트워크 관리 복잡<br>- 데이터 일관성 유지 어려움<br>- 초기 투자 비용 높음<br>- 로드 밸런서 필요함<br>- 앱 수정 필요함<br>- 추가 설계 필요함 |



### 로드밸런서

> 좀더 자세하게 알아보자

여러 서버에 트래픽을 고르게 분산시켜주는 장치나 소프트웨어임. 

서버가 여러 대 있을 때 한 서버에만 부하가 몰리지 않도록 트래픽을 나눠줌. 

덕분에 서버 다운되는 걸 막고, 전체 시스템 성능을 향상시킬 수 있음. 

주로 웹 서버나 애플리케이션 서버 앞단에 위치함. 
| **방법**           | **설명**                                        | **장점**                                     | **단점**                                    |
|--------------------|-------------------------------------------------|----------------------------------------------|---------------------------------------------|
| **하드웨어 로드밸런서** | 전용 장비를 사용해 트래픽 분산함 (L4 스위치 같은거) | - 성능 뛰어남<br>- 안정적임<br>- 고급 기능 제공 | - 비용 비쌈<br>- 설정 복잡함<br>- 유연성 낮음 |
| **소프트웨어 로드밸런서** | 소프트웨어로 로드밸런싱 구현 (예: HAProxy, Nginx) | - 비용 저렴<br>- 설정 유연함<br>- 오픈소스 많음 | - 성능 제한<br>- 설정 복잡할 수 있음<br>- 버전에 따른 유지보수 필요 |
| **클라우드 로드밸런서**  | 클라우드 서비스에서 제공하는 로드밸런서 사용 (예: AWS ELB) | - 설정 간편<br>- 확장성 높음<br>- 관리 용이함   | - 종속성 있음<br>- 비용 발생<br>- 성능 제한 있을 수 있음 |
| **DNS 로드밸런서**      | DNS 라운드 로빈 방식으로 트래픽 분산함               | - 설정 간단<br>- 비용 저렴                    | - 세밀한 제어 어려움<br>- 성능 제한 있음    |

#### 성능 제한이 생기는 이유

###### 소프트웨어 로드밸런서

1. **서버 자원 의존**: 소프트웨어 로드밸런서는 일반 서버에서 동작하기 때문에 서버의 CPU, 메모리, 네트워크 대역폭 등에 의해 성능이 제한될 수 있음.
2. **네트워크 스택**: 네트워크 패킷을 처리하는 소프트웨어의 효율성에 따라 성능이 좌우됨. 고성능을 위해 최적화된 하드웨어에 비해 상대적으로 처리 속도가 느릴 수 있음.
3. **스케일링 한계**: 소프트웨어 로드밸런서는 하드웨어처럼 쉽게 확장되지 않기 때문에 트래픽이 급증할 경우 성능 저하가 발생할 수 있음.

###### 클라우드 로드밸런서

1. **공유 자원**: 클라우드 로드밸런서는 클라우드 제공자의 인프라를 공유하므로, 다른 사용자와 자원을 나눠 써야 함. 이로 인해 성능이 일정하지 않을 수 있음.
2. **네트워크 대역폭**: 클라우드 환경에서 제공되는 네트워크 대역폭이 제한적일 수 있음. 고성능 로드밸런싱을 위해서는 충분한 대역폭이 필요함.
3. **추가 비용**: 고성능을 위해 더 많은 자원을 할당받으려면 추가 비용이 발생할 수 있음. 비용을 절감하기 위해 자원을 제한하면 성능이 저하됨.

###### DNS 로드밸런서

1. **제어 한계**: DNS 로드밸런서는 단순히 IP 주소를 라운드 로빈 방식으로 분배하는 방식이기 때문에 세밀한 트래픽 제어가 어려움. 이는 성능 최적화에 한계를 줌.
2. **캐싱 문제**: DNS 레코드는 클라이언트와 ISP의 캐시에 저장되기 때문에, 변경 사항이 즉시 반영되지 않음. 이는 실시간 트래픽 분산에 영향을 줄 수 있음.
3. **지연 시간**: DNS 쿼리와 응답 과정에서 생기는 지연 시간이 있음. 이는 사용자 경험에 영향을 줄 수 있음.

#### 어떤 로드벨런서를 써야할지 고민 포인트

1. 트래픽 양과 성능 요구사항

- **트래픽 규모**: 처리해야 할 트래픽의 양이 얼마나 되는지 파악함. 대규모 트래픽을 처리해야 한다면 고성능 하드웨어 로드밸런서를 고려해야 함.
- **응답 시간**: 빠른 응답 시간이 필요한지 여부를 평가함. 실시간 애플리케이션이라면 성능이 중요한 요소가 됨.

2. 비용

- **초기 비용**: 하드웨어 로드밸런서는 초기 구축 비용이 높음. 예산에 따라 선택해야 함.
- **운영 비용**: 클라우드 로드밸런서는 사용량에 따라 비용이 발생함. 장기적인 운영 비용을 고려해야 함.

3. 유연성과 확장성

- **확장성**: 트래픽이 급증할 때 쉽게 확장할 수 있는지 평가함. 클라우드 로드밸런서는 확장성이 뛰어남.
- **유연성**: 설정과 변경이 얼마나 유연한지, 다양한 요구사항을 만족시킬 수 있는지 확인함. 소프트웨어 로드밸런서는 유연성이 높음.

4. 관리 및 유지보수

- **관리 편의성**: 관리와 유지보수가 얼마나 쉬운지 고려함. 클라우드 로드밸런서는 관리가 간편함.
- **기술 지원**: 기술 지원이 얼마나 잘 제공되는지 확인함. 하드웨어 로드밸런서는 보통 전문적인 기술 지원이 제공됨.

5. 보안

- **보안 기능**: SSL/TLS 종료, DDoS 방어 등 필요한 보안 기능을 제공하는지 평가함. 하드웨어 로드밸런서는 보안 기능이 뛰어남.
- **컴플라이언스**: 특정 법적 요구사항이나 규정을 준수해야 하는지 여부를 고려함.

6. 기술 스택과 통합

- **기존 인프라**: 현재 사용 중인 인프라와의 호환성을 고려함. 기존 기술 스택과 잘 통합되는지 확인함.
- **오픈소스 vs 상용**: 오픈소스 소프트웨어를 사용할지, 상용 소프트웨어를 사용할지 결정함. 오픈소스는 비용이 저렴하나, 자체적인 기술 역량이 필요함.

7. 사용 사례

- **웹 애플리케이션**: 주로 웹 트래픽을 처리해야 한다면 Nginx나 HAProxy 같은 소프트웨어 로드밸런서가 적합할 수 있음.
- **엔터프라이즈 애플리케이션**: 고성능과 안정성이 중요한 엔터프라이즈 애플리케이션이라면 F5 BIG-IP 같은 하드웨어 로드밸런서가 적합함.
- **클라우드 네이티브 애플리케이션**: 클라우드 환경에서 운영되는 애플리케이션이라면 AWS ELB 같은 클라우드 로드밸런서가 적합함.



#### NginX

주요 특징

1. **높은 성능**: NginX는 이벤트 기반(non-blocking) 아키텍처를 사용하여 높은 동시성 처리를 제공함. 이는 많은 수의 연결을 효율적으로 처리할 수 있게 해줌. (HW 스팩, 네트워크 등 환경에 영향을 받아서 직접 테스트로 성능을 확인해봐야함. 고성능기준으로 초당 50000건 정도 정적파일 호스팅이 가능한것으로 보임)
2. **안정성**: NginX는 대규모 트래픽을 처리할 때도 안정적으로 동작함. 이는 대형 웹사이트와 애플리케이션에서 널리 사용되는 이유 중 하나임.
3. **낮은 리소스 사용량**: CPU와 메모리 사용량이 적어 서버 리소스를 효율적으로 활용할 수 있음.
4. **확장성**: 여러 인스턴스를 쉽게 확장할 수 있으며, 다양한 모듈을 통해 기능을 확장할 수 있음.

주요 기능

1. **웹 서버**: 정적 파일(HTML, CSS, JS 등)을 제공하는 웹 서버로 사용될 수 있음.
2. **리버스 프록시**: 클라이언트 요청을 백엔드 서버로 전달하는 리버스 프록시 서버로 사용됨. 이는 로드 밸런싱과 보안, 캐싱 기능을 제공함.
3. **로드 밸런서**: 여러 백엔드 서버로 트래픽을 분산시켜 부하를 분산하고 가용성을 높임. 라운드 로빈, IP 해시, 최소 연결 등의 로드 밸런싱 알고리즘을 지원함.
4. **HTTP 캐시**: 정적 콘텐츠와 동적 콘텐츠를 캐싱하여 응답 시간을 줄이고 서버 부하를 줄임.
5. **SSL/TLS 지원**: HTTPS를 통해 SSL/TLS를 지원함.
6. **압축**: Gzip을 사용하여 응답 데이터를 압축하여 전송 속도를 향상시킴.
7. **접속 제어**: IP 주소 기반 접근 제어, 요청 제한, 속도 제한 등을 통해 보안을 강화할 수 있음.
8. **다양한 모듈**: 여러 가지 추가 기능을 제공하는 모듈을 통해 기능을 확장할 수 있음. 예를 들어, Lua 모듈을 사용하여 동적 스크립트를 실행할 수 있음.

사용 사례

1. **정적 파일 제공**: 웹사이트의 정적 파일을 제공하는 기본 웹 서버로 사용됨.
2. **리버스 프록시 및 로드 밸런서**: 여러 애플리케이션 서버에 트래픽을 분산시키고, 백엔드 서버를 보호하기 위해 사용됨.
3. **API 게이트웨이**: API 요청을 처리하고 백엔드 서비스로 전달하는 API 게이트웨이로 사용됨.
4. **콘텐츠 캐싱**: 웹 콘텐츠를 캐싱하여 응답 시간을 줄이고 서버 부하를 감소시킴.
5. **보안**: SSL/TLS 암호화를 통해 보안을 강화하고, DDoS 공격 방어 및 접근 제어 기능을 제공함.

성능 최적화 할만한 방법

1. **워커 프로세스 (worker processes)**: CPU 코어 수에 맞게 워커 프로세스 수를 설정.
2. **워커 커넥션 (worker connections)**: 워커 프로세스가 처리할 수 있는 최대 연결 수를 설정.
3. **Gzip 압축**: 응답 데이터를 압축하여 전송 효율을 높임.
4. **캐싱**: 정적 파일 및 동적 콘텐츠를 캐싱하여 응답 시간을 줄이고 서버 부하를 감소시킴.
5. **커넥션 타임아웃**: 비효율적인 연결을 줄이기 위해 적절한 타임아웃 설정.

#### Kubernetes에서는 어떻게 하나?

k8s에서는 트래픽을 여러 pod에 분산해야함. 클러스터 자체에서 로드밸런싱 방법을 제공하고 yaml에 이를 설정해야함. 

Service에서 클러스터IP, 노드포트, LB를 사용해도 됨. Ingress 트래픽을 관리할 수 있음.



### 데이터베이스 다중화

#### 주요 개념

1. 리플리케이션(Replication)

- **마스터-슬레이브**: 마스터 DB가 쓰기 작업을 처리하고, 슬레이브 DB가 읽기 작업을 처리함. 마스터에서 슬레이브로 데이터를 복제함.
- **마스터-마스터**: 두 개 이상의 마스터 DB가 서로 데이터를 복제하며, 읽기와 쓰기 작업을 모두 처리할 수 있음. 설정이 까다로움.

2. 샤딩(Sharding)

- 데이터를 여러 샤드(Shard)로 나누어 분산 저장함. 각 샤드는 독립적인 DB임.
- 큰 데이터를 처리할 때 유용함. 하지만 샤딩 키를 잘못 선택하면 성능이 저하될 수 있음.

3. 로드 밸런싱(Load Balancing)

- 데이터베이스 앞에 로드 밸런서를 두어 트래픽을 여러 DB 인스턴스로 분산시킴.
- 읽기 전용 복제본(Read Replica)을 사용하여 읽기 작업을 분산시킴.

4. 클러스터링(Clustering)

- 여러 DB 인스턴스를 하나의 클러스터로 묶어 고가용성을 제공함.
- 대표적으로 MySQL의 Galera Cluster, PostgreSQL의 Patroni 등이 있음.

5. 자동 페일오버(Auto Failover)

- 주 DB가 장애가 발생하면 자동으로 백업 DB로 전환됨.
- HAProxy, Keepalived 같은 도구를 사용함.

6. 분산 데이터베이스(Distributed Database)

- 데이터베이스 자체가 분산 시스템으로 설계됨.
- 예: Apache Cassandra, Google Spanner.

#### 주요 DB 비교

| 기능/전략          | Oracle DB                          | MySQL                                 |
|-------------------|------------------------------------|---------------------------------------|
| 리플리케이션      | - Oracle Data Guard<br>- Oracle GoldenGate | - Master-Slave Replication<br>- Master-Master Replication |
| 클러스터링        | - Oracle Real Application Clusters (RAC) | - MySQL InnoDB Cluster<br>- Galera Cluster |
| 샤딩              | - Oracle Sharding                  | - MySQL NDB Cluster                   |
| 자동 페일오버     | - Oracle Data Guard Fast-Start Failover | - MHA (Master High Availability)<br>- Orchestrator |
| 백업 및 복구      | - RMAN (Recovery Manager)          | - mysqldump<br>- MySQL Enterprise Backup |
| 로드 밸런싱       | - Oracle RAC Load Balancing        | - ProxySQL<br>- HAProxy               |
| 분산 데이터베이스 | - Oracle GoldenGate for Big Data   | - Vitess                              |

### 재해복구(DR)

DB관련:

- **동기 복제**: 두 시스템 간의 데이터 일관성을 보장하지만, 지연 시간 증가 가능성 있음.
- **비동기 복제**: 지연 시간이 적지만, 데이터 일관성 보장은 약함.

서버관련:

- **핫 사이트(Hot Site)**: 실시간으로 운영 가능한 대체 데이터센터로, 즉시 복구 가능. 고비용.
- **웜 사이트(Warm Site)**: 기본적인 하드웨어와 네트워크 구성이 되어 있으며, 데이터 복구에 시간이 걸림.
- **콜드 사이트(Cold Site)**: 기본적인 시설만 갖춰져 있으며, 복구에 가장 많은 시간이 소요되지만 비용이 저렴함.



