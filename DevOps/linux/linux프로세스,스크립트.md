# Linux 프로세스

> 리눅스를 전반적으로 정리합니다.

## 프로세스 확인/모니터링

리눅스에서 프로세스를 확인하고 모니터링하는 다양한 방법이 있습니다. 몇 가지 일반적인 방법을 아래에 안내해드리겠습니다:

1. **ps 명령어**: `ps` 명령어는 현재 실행 중인 프로세스를 확인하는 가장 기본적인 방법입니다. 다양한 옵션을 사용하여 프로세스 정보를 출력할 수 있습니다. 일반적으로 사용되는 옵션은 아래와 같습니다:
   - `ps aux`: 모든 사용자의 모든 프로세스를 자세한 정보와 함께 보여줍니다.
   - `ps -ef`: 모든 프로세스를 자세한 정보와 함께 보여줍니다.
   - `ps -e`: 모든 프로세스의 간단한 정보를 보여줍니다.
2. **top 명령어**: `top` 명령어는 실시간으로 시스템의 상태를 모니터링하는 유용한 도구입니다. `top` 명령어를 실행하면 CPU 사용량, 메모리 사용량, 실행 중인 프로세스 등의 정보를 볼 수 있습니다. 프로세스 목록은 CPU 사용량이 높은 순서로 정렬되며, 상태가 업데이트됩니다. `top`을 종료하려면 `q` 키를 누르면 됩니다.
3. **htop**: `htop`은 `top` 명령어의 향상된 버전으로, 더 직관적이고 사용하기 쉬운 인터페이스를 제공합니다. `htop`은 `top`에 비해 더 많은 정보와 기능을 제공하며, 프로세스를 조작하고 모니터링하는 데 유용합니다. `htop`은 일반적으로 시스템에 별도로 설치해야 할 수도 있습니다.
4. **pstree 명령어**: `pstree` 명령어는 프로세스의 트리 구조를 시각적으로 보여줍니다. 특정 프로세스의 자식 프로세스와 부모 프로세스를 확인하는 데 유용합니다. 예를 들어, `pstree -p` 명령어를 사용하면 프로세스 트리와 해당 프로세스의 PID를 함께 출력합니다.
5. **pgrep, pkill 명령어**: `pgrep` 명령어를 사용하여 특정 조건에 맞는 프로세스의 PID를 찾을 수 있습니다. `pkill` 명령어를 사용하여 특정 조건에 맞는 프로세스를 종료할 수 있습니다. 예를 들어, `pgrep firefox` 명령어는 "firefox"를 포함한 프로세스의 PID를 찾습니다.

이 외에도 다양한 도구와 명령어가 있으며, 사용 가능한 리눅스 배포판 및 버전에 따라 다를 수 있습니다. 사용 목적과 요구 사항에 따라 적절한 도구를 선택하여 프로세스를 확인하고 모니터링할 수 있습니다.



## kill

리눅스에서 `kill` 명령어는 프로세스를 종료시키는 데 사용되는 명령어입니다. 이 명령어는 프로세스에 시그널(signal)을 보내어 프로세스를 제어하며, 일반적으로 프로세스를 강제로 중단시키는 데 사용됩니다.

`kill` 명령어는 다음과 같은 형식으로 사용됩니다:

```
kill [옵션] [프로세스 ID 또는 작업 번호]
```

주요 옵션 중 일부는 다음과 같습니다:

- `-l`: 사용 가능한 시그널 목록을 출력합니다.
- `-s 시그널`: 특정 시그널을 지정합니다. 시그널 번호 또는 이름을 사용할 수 있습니다.
- `-a`: 자신의 프로세스를 제외하고 모든 프로세스에 시그널을 보냅니다.
- `-p`: 특정 프로세스 ID에 시그널을 보냅니다.

프로세스 ID는 `ps` 명령어를 사용하여 확인할 수 있습니다. 예를 들어, 다음 명령어는 실행 중인 모든 프로세스를 나열합니다:

```
ps aux
```

보통 `kill` 명령어는 다음과 같이 사용됩니다:

```
kill 1234
```

위의 예시에서 `1234`는 종료하려는 프로세스의 ID입니다. 프로세스 ID 대신 작업 번호(job number)를 사용할 수도 있습니다. 작업 번호는 `jobs` 명령어를 사용하여 확인할 수 있습니다.

추가적으로, 일반적으로 사용되는 몇 가지 시그널은 다음과 같습니다:

- `SIGTERM` (기본 시그널): 프로세스에게 종료 요청을 보냅니다.
- `SIGKILL`: 프로세스를 강제로 종료시킵니다.
- `SIGSTOP`: 프로세스를 일시 중지시킵니다.

`kill` 명령어는 프로세스를 종료시키는 강력한 도구이므로 신중하게 사용해야 합니다.

리눅스에서 일반적으로 사용되는 몇 가지 시그널과 해당하는 숫자 옵션은 다음과 같습니다:

- `SIGHUP` (1): 제어 터미널이 닫힐 때 발생합니다. 일반적으로 데몬 프로세스 재시작을 트리거하는 데 사용됩니다.
- `SIGINT` (2): 인터럽트 시그널로, Ctrl+C를 누를 때 발생합니다. 프로그램을 종료하도록 요청합니다.
- `SIGQUIT` (3): 종료 시그널로, Ctrl+\를 누를 때 발생합니다. 프로그램을 종료하고 코어 덤프(core dump)를 생성합니다.
- `SIGKILL` (9): 강제 종료 시그널로, 프로세스를 즉시 종료시킵니다. 프로세스는 이 시그널을 무시할 수 없습니다.
- `SIGTERM` (15): 종료 시그널로, 프로세스에게 정상적으로 종료하도록 요청합니다. 프로세스는 이 시그널을 처리하거나 무시할 수 있습니다.

### 종료 코드, $?

리눅스에서 프로세스가 시그널에 의해 종료될 때, 해당 프로세스는 종료 코드(exit code)를 반환합니다. 종료 코드는 프로세스가 종료되는 이유를 알려주는 정수 값입니다. 이 종료 코드는 종종 프로세스 상태를 확인하고 에러 조건을 파악하는 데 사용됩니다.

종료 코드는 `wait()` 또는 `waitpid()` 시스템 호출을 통해 확인할 수 있습니다. 일반적으로 정수 값으로 반환되며, 다음과 같은 종류의 종료 코드가 있을 수 있습니다:

- `0`: 성공적인 종료를 나타냅니다. 프로세스가 정상적으로 실행되었고, 어떠한 에러나 문제도 발생하지 않았음을 의미합니다.
- 양수 값: 일반적으로 비정상적인 종료를 나타냅니다. 종료 코드의 구체적인 의미는 프로그램에 따라 다를 수 있습니다. 종료 코드의 값은 보통 프로그래머가 지정하거나 시스템에 의해 정의됩니다.
- 음수 값: 보통 시그널에 의한 종료를 나타냅니다. 음수 종료 코드는 해당하는 시그널 번호의 절댓값으로 표시됩니다. 예를 들어, `-9`는 `SIGKILL` 시그널에 의한 종료를 의미합니다.

종료 코드는 주로 셸 스크립트나 다른 프로세스 간 통신에서 사용되며, 종료 상태를 확인하고 이를 기반으로 적절한 조치를 취할 수 있습니다. 종료 코드는 일반적으로 `$?` 변수를 통해 셸 스크립트에서 확인할 수도 있습니다.

프로세스의 종료 코드는 프로세스가 종료될 때 발생하며, 프로세스가 시그널을 수신하거나 직접 `exit()` 함수를 호출하여 종료 코드를 설정할 수 있습니다.

### kill 9 vs kill 15

`SIGKILL`과 `SIGTERM`은 둘 다 프로세스를 종료하는 시그널이지만, 각각 다른 방식과 장단점을 가지고 있습니다.

**SIGKILL의 장단점:**

장점:

- 강제로 프로세스를 종료시킬 수 있습니다. `SIGKILL`은 프로세스가 해당 시그널을 무시할 수 없으므로, 거의 모든 경우에 프로세스를 종료할 수 있습니다.
- 시그널을 처리하는 추가 로직이 필요하지 않습니다. `SIGKILL`은 시그널을 처리할 기회를 주지 않고 즉시 종료되므로, 프로세스는 어떤 동작도 수행하지 않습니다.

단점:

- 강제 종료로 인해 프로세스가 정리되지 않을 수 있습니다. `SIGKILL`은 프로세스에 정리 작업을 수행할 기회를 주지 않으므로, 파일 핸들러 해제, 자원 반납 등의 작업이 제대로 이루어지지 않을 수 있습니다.
- 프로세스가 예기치 않게 종료되면 데이터 손실이 발생할 수 있습니다. 프로세스가 중요한 작업을 수행 중인 경우, 갑작스런 종료로 인해 작업이 완료되지 못하고 데이터가 손실될 수 있습니다.

**SIGTERM의 장단점:**

장점:

- 프로세스에게 정상적으로 종료하도록 요청합니다. `SIGTERM`은 소프트 종료 시그널로, 프로세스에게 종료를 요청하고 정리 작업을 수행할 기회를 줍니다.
- 정리 작업이 가능하므로, 데이터의 안전한 저장이 가능합니다. 프로세스는 `SIGTERM` 시그널을 수신하여 자원 해제, 파일 저장 등의 작업을 수행할 수 있습니다.

단점:

- 프로세스가 `SIGTERM` 시그널을 무시할 수 있습니다. 일부 프로세스는 `SIGTERM`을 처리하지 않거나, 일부 동작만을 수행하고 종료하지 않을 수 있습니다.
- 일부 상황에서 `SIGTERM`으로도 프로세스를 정상적으로 종료할 수 없는 경우가 있을 수 있습니다. 예를 들어, 프로세스가 무한 루프에 갇혀있는 경우나 비정상적으로 동작하는 경우 등에서는 `SIGTERM`으로 종료되지 않을 수 있습니다.

요약하자면, `SIGKILL`은 강제로 프로세스를 종료시키는 강력한 방법이지만, 정리 작업이나 데이터 보존에 대한 보장이 없습니다. 반면, `SIGTERM`은 프로세스에게 종료를 요청하고 정리 작업을 수행할 수 있는 기회를 주지만, 프로세스가 시그널을 무시할 수 있고 정상적인 종료를 보장하지는 않습니다. 따라서, 프로세스를 종료시킬 때에는 우선적으로 `SIGTERM`을 사용하여 정상적인 종료를 시도하고, 필요한 경우에만 `SIGKILL`을 사용하는 것이 좋습니다.



## 편집기

### vim

Vim은 유닉스 기반 시스템에서 널리 사용되는 텍스트 편집기입니다. Vim은 명령 모드(Command mode), 입력 모드(Insert mode), 및 마지막 행 모드(Last Line mode)로 구성되어 있습니다. 아래에 Vim의 주요 명령어와 사용법을 설명하겠습니다:

1. **Vim 시작하기**:
   - Vim을 실행하려면 터미널 또는 콘솔에서 `vim` 명령어를 입력합니다.
   - `vim <파일 경로>`를 입력하여 특정 파일을 Vim으로 엽니다. 파일이 존재하지 않으면 새로운 파일로 열립니다.
2. **명령 모드(Command mode)**:
   - Vim을 실행하면 기본적으로 명령 모드로 시작합니다.
   - 명령 모드에서는 다양한 명령어를 입력하여 편집기를 제어할 수 있습니다.
3. **입력 모드(Insert mode)**:
   - 입력 모드로 전환하려면 명령 모드에서 `i`를 누르거나 `a`를 누르면 현재 커서 위치에서 입력을 시작할 수 있습니다.
   - 입력 모드에서는 텍스트를 직접 입력하고 편집할 수 있습니다.
   - 입력을 마치고 명령 모드로 돌아가려면 `Esc` 키를 누릅니다.
4. **저장 및 종료**:
   - 명령 모드에서 `:w`를 입력하여 현재 파일을 저장할 수 있습니다.
   - 명령 모드에서 `:q`를 입력하여 Vim을 종료할 수 있습니다.
   - 변경 사항이 있고 저장하지 않은 경우, `:q!`를 입력하여 강제로 종료할 수 있습니다.
5. **편집 및 이동**:
   - `h`, `j`, `k`, `l` 키를 사용하여 좌측, 아래, 위, 우측으로 커서를 이동시킵니다.
   - `x`를 눌러 현재 커서 위치의 문자를 삭제합니다.
   - `dd`를 입력하여 현재 줄을 삭제합니다.
   - `yy`를 입력하여 현재 줄을 복사합니다.
   - `p`를 입력하여 복사한 텍스트를 현재 커서 아래에 붙여넣습니다.
6. **검색 및 치환**:
   - `/` 또는 `?`를 입력하여 텍스트를 검색할 수 있습니다. `/`는 앞으로, `?`는 뒤로 검색합니다. 예를 들어, `/keyword`는 "keyword"를 앞으로 검색합니다.
   - 검색된 단어를 찾은 후 `n`을 눌러 다음 발생을 찾을 수 있습니다.
   - `:s/old/new/g`를 입력하여 "old"를 "new"



## Shell script

### 명령어

Shell 스크립트에서는 다양한 명령어와 도구를 사용할 수 있습니다. 아래에 몇 가지 일반적인 Shell 스크립트 명령어를 나열하였습니다:

1. **변수와 할당**: 변수를 선언하고 값을 할당하는 데 사용됩니다.
   - `variable=value`: 변수에 값을 할당합니다.
   - `echo $variable`: 변수의 값을 출력합니다.
2. **조건문**: 조건에 따라 코드의 흐름을 제어하는 데 사용됩니다.
   - `if`-`else` 문: 조건을 평가하고 해당하는 코드 블록을 실행합니다.
   - `case` 문: 다중 조건을 검사하고 각 조건에 해당하는 코드 블록을 실행합니다.
3. **반복문**: 코드 블록을 반복적으로 실행하는 데 사용됩니다.
   - `for` 루프: 리스트 또는 범위의 항목을 반복하면서 코드를 실행합니다.
   - `while` 루프: 조건이 참인 동안 코드를 반복 실행합니다.
4. **함수**: 코드의 재사용을 위해 함수를 정의하고 호출하는 데 사용됩니다.
   - `function_name() { ... }`: 함수를 정의합니다.
   - `function_name`: 함수를 호출합니다.
5. **입출력**: 사용자 입력을 받고 표준 입력/출력을 다루는 데 사용됩니다.
   - `read`: 사용자로부터 입력을 받습니다.
   - `echo`: 텍스트를 출력합니다.
   - `printf`: 서식 지정된 출력을 수행합니다.
6. **파일 조작**: 파일 및 디렉토리를 생성, 읽기, 쓰기, 삭제하는 데 사용됩니다.
   - `touch`: 파일을 생성하거나 수정합니다.
   - `rm`: 파일이나 디렉토리를 삭제합니다.
   - `cp`: 파일이나 디렉토리를 복사합니다.
   - `mv`: 파일이나 디렉토리를 이동하거나 이름을 변경합니다.
7. **파일 조건**: 파일의 존재, 유형, 속성을 확인하는 데 사용됩니다.
   - `test` 또는 `[ ]`: 조건을 평가합니다.
   - `-f`: 파일이 존재하는지 확인합니다.
   - `-d`: 디렉토리인지 확인합니다.
8. **파이프라인과 리다이렉션**: 명령어의 출력을 다른 명령어로 전달하거나 파일로 리다이렉션하는 데 사용됩니다.
   - `|`: 명령어의 출력을 다른 명령어로 전달합니다.
   - `>`: 출력을 파일로 리다이렉션합니다.
   - `<`: 파일을 입력으로 리다이렉션합니다.
9. **기타 유틸리티**: 기타 유틸리티 및 명령어를 사용할 수 있습니다.
   - `grep`: 텍스트에서 패턴을 검색합니다.
   - `awk`: 텍스트를 처리하고 보고서를 생성합니다.
   - `sed`: 텍스트를 편집하고 변환합니다.

