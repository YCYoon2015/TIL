# 221027 프로그래머스

## 파괴되지 않은 건물 (Level 3)

> https://school.programmers.co.kr/learn/courses/30/lessons/92344

### 문제 설명

N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다.

적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다.
예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다.

![04_2022_공채문제_파괴되지않은건물_01.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9932445f-244d-4188-a559-f16044cfa4d3/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_01.png)

첫 번째로 적이 맵의 **(0,0)부터 (3,4)까지 공격하여 4만큼** 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.

![04_2022_공채문제_파괴되지않은건물_02.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/2a3df058-d7b6-4317-9352-8f9713a9424a/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_02.png)

두 번째로 적이 맵의 **(2,0)부터 (2,3)까지 공격하여 2만큼** 건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다.

![04_2022_공채문제_파괴되지않은건물_03.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/94a07a93-71e3-447c-83cf-f855176e28c1/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_03.png)

세 번째로 아군이 맵의 **(1,0)부터 (3,1)까지 회복하여 2만큼** 건물의 내구도를 높이면 아래와 같이 **2개의 건물이 파괴되었다가 복구**되고 2개의 건물만 파괴되어있는 상태가 됩니다.

![04_2022_공채문제_파괴되지않은건물_04.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/145dfcf7-02aa-44fd-b01b-ff56fb5b0dad/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_04.png)

마지막으로 적이 맵의 **(0,1)부터 (3,3)까지 공격하여 1만큼** 건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다. **(내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.)**

![04_2022_공채문제_파괴되지않은건물_05.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9ce05af0-e5b9-483a-aeb4-d7c0624c2dfb/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_05.png)

최종적으로 총 10개의 건물이 파괴되지 않았습니다.

건물의 내구도를 나타내는 2차원 정수 배열 `board`와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열 `skill`이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요.

### 알고리즘 포인트

구현, 누적합

### 나의 답안

```python
def solution(board, skill):
    n = len(board) + 1
    m = len(board[0]) + 1
    calc = [[0]*m for _ in range(n)]
    
    for s in skill:
        if s[0] == 1:
            degree = s[5]  * (-1)
        else:
            degree = s[5]
        
        r1, c1, r2, c2 = s[1], s[2], s[3], s[4]
        calc[r1][c1] += degree
        calc[r1][c2+1] -= degree
        calc[r2+1][c1] -= degree
        calc[r2+1][c2+1] += degree
    
    # 누적합 계산
    for i in range(n):
        for j in range(1, m):
            calc[i][j] += calc[i][j-1]
    
    for j in range(m):
        for i in range(1, n):
            calc[i][j] += calc[i-1][j]
    
    # board 적용 & 건물 계산
    cnt = 0
    for r in range(n-1):
        for c in range(m-1):
            board[r][c] += calc[r][c]
            if board[r][c] > 0:
                cnt += 1
                
    return cnt
```

### 생각

일반적인 브루드포스 방식으로 구현했고 시간 초과가 발생했다. 문제를 그대로 구현하는것은 난이도가 높지 않다.

문제의 핵심은 2차원 리스트를 완전탐색하지 않는 방식으로 계산값을 전달하는 것이다. (r1, c1) ~ (r2, c2) 까지의 합을 저장하는 방법으로 누적합 리스트를 이용하는것이 풀이의 핵심이다. 누적합이라는 개념을 아는지 모르는지 판단하는 문제라고 생각한다. 

누적합의 개념을 사용하면 구현은 어렵지 않았다. 
